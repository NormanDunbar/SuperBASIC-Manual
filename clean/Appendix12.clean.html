    
<H3>A12 DEVICE DRIVERS</H3>

<P>
    
<H3>A12.1 DEVICES IN GENERAL</H3>

<P>
    
<P>This chapter informs you about the usage of the various devices available on the QL and its compatibles. The QL's operating system QDOS is what is known as device independent meaning that a program can be written to use any device without having to actually know its details (an exception to this rule is in the use of standard pipes). Programs should be written so that (at least) all of these devices can be accessed by the user as required.</P>
    
<P>Device Drivers are programs which usually create a connection between hardware devices and software, in that they install a QDOS device to interface from software to the hardware. For example a printer is obviously hardware but you do not have to <SPAN style="font-style: italic;">POKE</SPAN> around in memory to get something printed, you can simply open a <SPAN style="font-style: italic;">SER</SPAN> or <SPAN style="font-style: italic;">PAR</SPAN> channel, dump your text to that channel and voila it appears on the paper. All communication with drivers must go through channels, whose name is very well chosen: they take data from the program and transport it to the device driver.</P>
    <OL>
      <LI>The program opens channel and writes or reads data to/from that channel...</LI>
      <LI>The channel forwards the data (also instructions) to the device drivers...</LI>
      <LI>The driver is a kind of translator which understands the language of the hardware...</LI>
      <LI>A hardware interface translates computer codes into electrical signals...</LI>
      <LI>The hardware performs physical actions, eg. printing or reading from a floppy disk.</LI>
    </OL>
    
<P>But devices can be used for all kind of connections, there are even general devices for communication between jobs (<SPAN style="font-style: italic;">PIPE</SPAN> and <SPAN style="font-style: italic;">HISTORY</SPAN>) and devices which interface in a special way to other devices (<SPAN style="font-style: italic;">DEV</SPAN> and <SPAN style="font-style: italic;">PTH</SPAN>). So the last two steps in the above figure are not obligatory, they can be different, ie. non-hardware.</P>
    
<P>Devices fall into two categories, directory devices (such as <SPAN style="font-style: italic;">FLP</SPAN>) and non-directory devices. The latter may also be further sub-divided into window devices (devices which access the screen, such as scr) and other devices. All devices (other than window devices) accept the <SPAN style="font-style: italic;">WIDTH</SPAN> command.</P>
    <PRE>             all devices
               /      \
              /        \
directory devices    non-directory devices
                         /           \
                        /             \
              window devices       other devices
</PRE>
    
<P>Further, if Toolkit II is present, or you are using a THOR XVI, certain commands will support default devices and also sub-directories on Level-2 directory devices.</P>
    
<P>Remember that device names can be in either upper or lower case, or even mixed case, that does not matter at all. Device independent programs should be fully configurable with regard to device names (eg. printer) and offer up to 42 characters for each device name. However, the ...<SPAN style="font-style: italic;">_USE</SPAN> style commands and the <SPAN style="font-style: italic;">DEV</SPAN> device help to overcome problems in this respect.</P>
    
<H3>A12.2 DIRECTORY DEVICE DRIVERS</H3>

<P>
    
<P>Data in the form of files can be stored on various different directory device drivers, some of which allow data to be stored when the computer is switched off (such as Microdrives and disks) and others which lose their contents when the QL is reset or switched off (such as ramdisks).</P>
    
<P>Such media must be <SPAN style="font-style: italic;">FORMAT</SPAN>ted prior to use in order to prepare them for use by the computer.</P>
    
<P>In order to speed up reading of these devices, unused parts of the computer's memory are set aside to act as slave blocks which store copies of as much of the contents of the device as possible. Then, when that same information is requested again, the computer need only check that the data held in the slave blocks is the same as on the device, and will then access the data from the slave blocks. This can however slow down the initial access times (see <SPAN style="font-style: italic;">DEL_DEFB</SPAN>).</P>
    
<P>Each device contains a main directory which is made up of a copy of the 64-byte file header for each file which is (or has been) stored on the device. This main directory is then examined by commands such as <SPAN style="font-style: italic;">DIR</SPAN> to produce a list of the files contained on that device. The file headers contain a host of different information about each file, including the name of the file, its type and the length of the file (see <SPAN style="font-style: italic;">FGETH$</SPAN>).</P>
    
<P>When a file is accessed, various details (such as date-stamping creation and update dates) are updated.</P>
    
<P>The way in which information is stored on a directory device really depends upon the Level of device driver installed (see Sections A12.6 - A12.8 below).</P>
    
<P>Details of the types of Directory Devices follow:</P>
    
<H3></H3>

<P>
    
<H3>MICRODRIVE (MDV)</H3>

<P>
    
<P>Syntax: <SPAN style="font-style: italic;">MDVn_file</SPAN> <SPAN style="font-style: italic;">(QL ROM)</SPAN>
    or [<SPAN style="font-style: italic;">MDVn_</SPAN>]<SPAN style="font-style: italic;">file</SPAN> <SPAN style="font-style: italic;">(Toolkit II only)</SPAN>
    Location: <SPAN style="font-style: italic;">QL ROM, THOR XVI</SPAN></P>
    
<P>This is the only standard directory device driver.</P>
    
<P>Microdrive cartridges are a continuous loop of video tape which store data in packets of 512 bytes (known as sectors). There is a theoretical maximum of 255 sectors on a Microdrive cartridge, although in practice the formatted number of sectors tends to be around 210 to 220.</P>
    
<P>The tape has to be searched serially in order to find the desired information which causes delay as the whole tape may have to be wound through in order to find the information. This is where slave blocks save a lot of time.</P>
    
<P>The standard QL supports two Microdrives (the slots to the right of the keyboard) into which Microdrive cartridges can be inserted on which the data is to be stored. However, up to a maximum of eight Microdrive ports can actually be recognised, if additional Microdrives are added by means of the Microdrive expansion port which is situated in the right hand side of the QL by the reset button.</P>
    
<P>The THOR XVI, and QL emulators do not possess any Microdrives, although the THOR does still recognise the device name, as it was originally envisaged that a separate Microdrive might be made to link up with the THOR in order to retain compatibility. The QL emulators will simply not find any Microdrive device like <SPAN style="font-style: italic;">MDV1_</SPAN>, error -7 is produced. SMSQ/E also does not recognise the Microdrives.</P>
    
<P>Unfortunately, unless you have Toolkit II or Minerva, Microdrive files are not date-stamped with the creation and update dates.</P>
    
<P>Unless you have Toolkit II, the first syntax of this driver must be used, which specifies the number of the Microdrive port to access (<SPAN style="font-style: italic;">n</SPAN>), which must be in the range 1...8, followed by the name of the file or device to access (<SPAN style="font-style: italic;">file</SPAN>). If neither or these are specified, you are likely to receive the error 'Not Found' (-7), although whether or not the file has to be specified depends upon the command being executed.</P>
    
<P>If however, Toolkit II is present, the default devices are supported.</P>
    
<H3>Examples:</H3>

<P>
    
<P><SPAN style="font-style: italic;">LOAD mdv1_boot</SPAN></P>
    
<P><SPAN style="font-style: italic;">DIR mdv2_</SPAN></P>
    
<P>Microdrives will allow you to create a file with a null name, which will not be revealed on a directory listing, but which will operate in much the same way as any other file. For example, the following two lines are both acceptable:</P>
    
<P><SPAN style="font-style: italic;">SAVE mdv1_Myprog_bas</SPAN></P>
    
<P><SPAN style="font-style: italic;">SAVE mdv1_</SPAN></P>
    
<P>Note that Microdrives do not possess Level-2 drivers and sub-directories are therefore not supported. For example creating a directory with</P>
    
<P><SPAN style="font-style: italic;">MAKE_DIR mdv1_test_</SPAN></P>
    
<P>will produce error -15 and leave the file <SPAN style="font-style: italic;">test</SPAN> on mdv1_.</P>
    
<H3>FLOPPY DISK (FLP)</H3>

<P>
    
<P>Syntax: <SPAN style="font-style: italic;">FLPn_file</SPAN>
    or [<SPAN style="font-style: italic;">FLPn_</SPAN>]<SPAN style="font-style: italic;">file</SPAN> <SPAN style="font-style: italic;">(Toolkit II only)</SPAN>
    Location: <SPAN style="font-style: italic;">Disk expansion boards, THOR XVI, QL Emulators</SPAN></P>
    
<P>This driver is for what are commonly known as floppy disks. These come in various sizes, ranging from 3" to 8", although the QL standard is now 3.5" double sided disks with either double (720k) or extra density (3.2 MB).</P>
    
<P>The amount of space on a disk depends on the number of tracks on the disk, the number of sides which can be used and the disk density. However, all of the drivers meet with a standard Sinclair format, ensuring compatibility between different manufacturers.</P>
    
<P>The drivers allow the same syntax as the <SPAN style="font-style: italic;">MDV</SPAN> driver, although most disk expansion boards will support the second variant, as Toolkit II (or at least part of it) has become standard on disk interfaces.</P>
    
<H3>Examples:</H3>

<P>
    
<P><SPAN style="font-style: italic;">MERGE flp1_Simple_bas</SPAN></P>
    
<P><SPAN style="font-style: italic;">DATA_USE flp1_Quill</SPAN></P>
    
<P>Some boards (such as the Gold Card, QXL, Atari Emulators and SMSQ/E) support Level-2 commands and therefore sub-directories. Other expansion boards can be fitted with these new drivers by updating a ROM chip. Level-2 drivers store the directory details in a separate file for simplicity. Unfortunately, the main directory is stored in a file with a null name which will automatically overwrite any earlier file with a null name. To see the main directory file, use:</P>
    
<P><SPAN style="font-style: italic;">COPY flp1_ TO scr</SPAN></P>
    
<P>Sub-directories are stored in files with the name of the sub-directory. Such files have a file type of 255 and cannot be deleted or renamed until all of the files contained within that sub-directory have been removed.</P>
    
<P>Level-1 drivers supported files with null names in the same way as Microdrives (see above). On some old drivers <SPAN style="font-style: italic;">FLP</SPAN> may be replaced by <SPAN style="font-style: italic;">FDK</SPAN>.</P>
    
<H3>RAMdisk (RAM)</H3>

<P>
    
<P>Syntax: <SPAN style="font-style: italic;">RAMn_file</SPAN>
    or [<SPAN style="font-style: italic;">RAMn_</SPAN>]<SPAN style="font-style: italic;">file</SPAN> <SPAN style="font-style: italic;">(Toolkit II only)</SPAN>
    Location: <SPAN style="font-style: italic;">QJump RAMPRT, Expansion Boards, THOR XVI, ST/QL Emulators, SMSQ/E, QXL, QPC, Amiga QDOS Emulator</SPAN></P>
    
<P>This driver is used to set up areas of memory which can be used in much the same way as a floppy disk. Anything stored in a RAMdisk is lost when the QL is reset or switched off.</P>
    
<P>There are actually two types of RAMdisks: a dynamic RAMdisk and a fixed RAMdisk.</P>
    
<P>A fixed Ram disk is allocated a size when the <SPAN style="font-style: italic;">FORMAT</SPAN> command is used, and can contain anything between 3 sectors and the whole of free memory. Some fixed Ram disks (most notably the Qjump ram disk which is a standard) do not work on the Amiga- QDOS emulator - a slower public domain Ram disk which does work is supplied with the Emulator.</P>
    
<P>By contrast, a dynamic RAMdisk does not have a fixed size and is created when anything is written to it (do not use <SPAN style="font-style: italic;">FORMAT</SPAN>) - it then expands and contracts to fit the size of the files contained in the RAMdisk.</P>
    
<P>Dynamic RAMdisks (optionally fixed) are supplied as standard on most QL systems. The RAMdisk drivers allow exactly the same syntax to the <SPAN style="font-style: italic;">FLP</SPAN> driver, but the Miracle drivers (eg. Gold Card and Trump Card) support an extra syntax to format a RAMdisk to 255 sectors and copy a whole Microdrive cartridge into them, eg. <SPAN style="font-style: italic;">FORMAT ram1_mdv1</SPAN>.</P>
    
<H3>Example:</H3>

<P>
    
<P><SPAN style="font-style: italic;">WCOPY flp1_,ram2_</SPAN></P>
    
<P>Level-2 drivers commands and sub-directories are also supported for the QJump RAMdisk driver, eg. on Gold Cards and ST/QL Emulators.</P>
    
<H3>Hard Disk (WIN)</H3>

<P>
    
<P>Syntax: <SPAN style="font-style: italic;">WINn_file</SPAN>
    or [<SPAN style="font-style: italic;">WINn_</SPAN>]<SPAN style="font-style: italic;">file</SPAN>
    Location: Hard disk Interfaces, THOR XVI, QL Emulators</P>
    
<P>This device driver allows you to access a hard disk drive (including removeable hard disks). This operates a lot more quickly than a floppy disk (but not as quickly as a ram disk) and can store several megabytes of data.</P>
    
<P>Hard disks are built into nearly every system that can run a QL Emulator and are available as add-ons for a standard QL and AURORA system.</P>
    
<P>Please refer to the original manuals because the harddisk drivers all differ in <SPAN style="font-style: italic;">FORMAT</SPAN>ing.</P>
    
<P>Accessing a <SPAN style="font-style: italic;">WIN</SPAN> device from a program is just like accessing a <SPAN style="font-style: italic;">FLP</SPAN> or <SPAN style="font-style: italic;">RAM</SPAN> device.</P>
    
<H3>QL ROMDisq (ROM)</H3>

<P>
    
<P>Syntax: <SPAN style="font-style: italic;">ROM1_file</SPAN>
    or [<SPAN style="font-style: italic;">ROM1_</SPAN>]<SPAN style="font-style: italic;">file</SPAN> <SPAN style="font-style: italic;">(Toolkit II only)</SPAN>
    Location: <SPAN style="font-style: italic;">QLROMDisq board</SPAN></P>
    
<P>This is a board which plugs into the QL's ROM Cartridge port and provides a fixed ram disk of either 2 or 8 Megabytes. It is similar to a RAM disk in that it is very quick when loading files, but it has three main differences:</P>
    <UL>
      <LI>It retains its contents after the QL is switched off.</LI>
      <LI>You can only write data to it a limited number of times (100,000).</LI>
      <LI>It is fairly slow when you write files to it (with <SPAN style="font-style: italic;">SAVE</SPAN>, <SPAN style="font-style: italic;">SEXEC</SPAN> or <SPAN style="font-style: italic;">SBYTES</SPAN>).</LI>
    </UL>
    
<P>Because of these limits, this device is only really intended for storing files which will not change very often and are needed when the QL is started up (for example a new keyboard and language driver). A boot file stored on this device will be loaded when the QL is started up in preference to similar files on hard disks, floppy disks and microdrive cartridges.</P>
    
<P>The other main benefit of this device is that you can transfer whole set-ups across to another QL (instead of using lots of floppy disks or microdrives).</P>
    
<H3>A12.3 WINDOW DEVICE DRIVERS</H3>

<P>
    
<P>There are two types of window drivers, <SPAN style="font-style: italic;">CON</SPAN> and <SPAN style="font-style: italic;">SCR</SPAN>. The former (<SPAN style="font-style: italic;">CON</SPAN>) is linked with a keyboard queue and can therefore accept input, as well as echoing any characters typed on screen. The latter (<SPAN style="font-style: italic;">SCR</SPAN>) on the other hand is for output only to the screen.</P>
    
<P>Any channels opened using these screen drivers are known as windows, and may have a cursor attached to them. If a cursor is attached, then it will normally appear as a red blob on screen (the size and shape of the cursor may be redefined under Minerva v1.77+), and will flash when it is active (ie. when it will accept input).</P>
    
<P>When you press &lt;CTRL&gt;&lt;C&gt;, QDOS cycles through all of the current cursors, allowing you to access different Jobs. If you are using Minerva in its two screen mode, then each channel is also attached to a screen, which means that if you open a channel on scr0, then all output to that channel will appear on scr0 whether or not that is the currently Displayed Screen (see <SPAN style="font-style: italic;">MODE</SPAN>).</P>
    
<P>Also, when you press &lt;CTRL&gt;&lt;C&gt; on Minerva, it will switch to the screen attached to the newly activated channel (unfortunately in current versions of Minerva, this does not quite work as expected, since if the active cursor is on the non-Displayed Screen when you press &lt;CTRL&gt;&lt;C&gt; to move to a channel on the Displayed Screen, Minerva still switches screens, meaning that you are still not looking at the screen with the active cursor).</P>
    
<P>Whenever a new window is opened, it is opened with black paper and green ink. The specified pixel parameters are also rounded up to make them even (if necessary) to ensure that they can be correctly displayed in any screen mode. The smallest possible window is two pixels wide and one pixel high.</P>
    
<H3>Console (CON)</H3>

<P>
    
<P>Syntax: <SPAN style="font-style: italic;">CON</SPAN>[<SPAN style="font-style: italic;">&lt;size&gt;</SPAN>][<SPAN style="font-style: italic;">&lt;position&gt;</SPAN>][<SPAN style="font-style: italic;">&lt;buffer&gt;</SPAN>]
    Location: <SPAN style="font-style: italic;">QL ROM</SPAN></P>
    
<P>This type of screen device is used for both output to the screen and reading the keyboard via a queue attached to that window. Depending on the command being executed, characters typed on the keyboard may be echoed on screen. This type of channel must be opened if you wish to use <SPAN style="font-style: italic;">INPUT</SPAN> or <SPAN style="font-style: italic;">INKEY$</SPAN>.</P>
    
<P>There are various problems with <SPAN style="font-style: italic;">OPEN</SPAN>ing <SPAN style="font-style: italic;">CON</SPAN>sole devices over the Network (see <SPAN style="font-style: italic;">FSERVE</SPAN>).</P>
    
<P>When the computer is first started, there are three <SPAN style="font-style: italic;">CON</SPAN>sole channels open, #0, #1 and #2; none of which should be <SPAN style="font-style: italic;">CLOSE</SPAN>d or <SPAN style="font-style: italic;">OPEN</SPAN>ed, this is especially true for #0!</P>
    
<P>When opening a channel, you can specify the size and position of the window and also the length of the type-ahead buffer attached to that window. These can have the following values:</P>
    
<P><SPAN style="font-style: italic;">&lt;size&gt;</SPAN>This sets the size of the window in pixel co-ordinates. It should be specified in the form:</P>
    
<P>[<SPAN style="font-style: italic;">_WIDTH</SPAN>][<SPAN style="font-style: italic;">xHEIGHT</SPAN>]</P>
    
<P>where <SPAN style="font-style: italic;">WIDTH</SPAN> can have any value in the range 0...<SPAN style="font-style: italic;">SCR_XLIM</SPAN>; and <SPAN style="font-style: italic;">HEIGHT</SPAN> can have any value in the range 0...<SPAN style="font-style: italic;">SCR_YLIM</SPAN>. The maximum values are however also dependent on &lt;<SPAN style="font-style: italic;">position</SPAN>&gt;.</P>
    
<P>The default value for &lt;<SPAN style="font-style: italic;">size</SPAN>&gt; is _448x200.</P>
    
<P>&lt;<SPAN style="font-style: italic;">position</SPAN>&gt;This specifies the co-ordinates of the top left hand corner of the window and is in the form:</P>
    
<P><SPAN style="font-style: italic;">a</SPAN>[<SPAN style="font-style: italic;">X</SPAN>][<SPAN style="font-style: italic;">xY</SPAN>]</P>
    
<P>where <SPAN style="font-style: italic;">X</SPAN> and <SPAN style="font-style: italic;">Y</SPAN> can both be in the same range as <SPAN style="font-style: italic;">WIDTH</SPAN> and <SPAN style="font-style: italic;">HEIGHT</SPAN> (used in the &lt;<SPAN style="font-style: italic;">size</SPAN>&gt;). However, both <SPAN style="font-style: italic;">WIDTH+X</SPAN> and <SPAN style="font-style: italic;">HEIGHT+Y</SPAN> must also be within the ranges, otherwise an 'Out of Range' error will be reported.</P>
    
<P>The default &lt;<SPAN style="font-style: italic;">position</SPAN>&gt; is a32x16.</P>
    
<P>&lt;<SPAN style="font-style: italic;">buffer</SPAN>&gt;This part of the device name specifies the size of the input buffer associated with the window, which is in the form <SPAN style="font-style: italic;">_N</SPAN> bytes. This value affects how many characters can be stored in the channel's buffer before the keyboard has to be read again (this is known as the type-ahead buffer). Although this can have any value, a value of 128 bytes tends to be large enough for most tasks, and in fact this is the default.</P>
    
<P>Default Device: <SPAN style="font-style: italic;">CON_448x200a32x16_128</SPAN></P>
    
<H3><SPAN style="font-style: italic;">Examples:<BR></SPAN></H3>
    
<P><SPAN style="font-style: italic;"><SPAN style="font-style: italic;">OPEN #3,con_200</SPAN>Open channel #3 as CON_200x200a32x16_128</SPAN></P>
    
<P><SPAN style="font-style: italic;">OPEN #3,con__10</SPAN>Open channel #3 as CON_448x200a32x16_10</P>
    
<P><SPAN style="font-style: italic;">OPEN #3,cona12</SPAN>Open channel #3 as CON_448x200a12x16_128</P>
    
<P><SPAN style="font-style: italic;">OPEN #3,conax20_50</SPAN>Open channel #3 as CON_448x200a32x20_50</P>
    
<P>The STE/QL emulator (QVME) and also other other hardware support much higher resolutions than 512x256, eg. QVME can go up to 1024x1024 pixels. However, programs should be written so that they still work with all other resolutions. This can be achieved by reading the possible screen size from system variables (the Pointer Environment must be used) and by not accessing screen memory directly.</P>
    
<H3>Screen (SCR)</H3>

<P>
    
<P>Syntax: <SPAN style="font-style: italic;">SCR</SPAN>[&lt;<SPAN style="font-style: italic;">size</SPAN>&gt;][&lt;<SPAN style="font-style: italic;">position</SPAN>&gt;]
    Location: <SPAN style="font-style: italic;">QL ROM</SPAN></P>
    
<P>This is very similar to the <SPAN style="font-style: italic;">CON</SPAN>sole driver, except that <SPAN style="font-style: italic;">SCR</SPAN> channels are for output to the screen only. No buffer size is required. Trying to read input from a <SPAN style="font-style: italic;">SCR</SPAN> channel will give a 'Bad Parameter' (-15) error.</P>
    
<P>Please see the <SPAN style="font-style: italic;">CON</SPAN> Window Driver.</P>
    
<P>Default Device: <SPAN style="font-style: italic;">SCR_448x200a32x16</SPAN></P>
    
<H3><SPAN style="font-style: italic;">A12.4 OTHER DEVICE DRIVERS<BR></SPAN></H3>
    
<P><SPAN style="font-style: italic;">In the following, LF is the line feed (or newline) character CHR$(10), CR is the carriage return character (13, $0D) and FF is the form feed character CHR$(12). In some applications &lt;CTRL&gt;&lt;Z&gt; is used as an end of text character, CHR$(26).</SPAN></P>
    
<P><SPAN style="font-style: italic;">Both parallel and serial ports are means for the QL to access other hardware in the outside world (such as printers, modems and scanners). Serial ports are so called because data is sent serially, one byte at a time. On the other hand, parallel ports allow several bytes to be sent at the same time and are therefore quicker.</SPAN></P>
    
<P><SPAN style="font-style: italic;">Many printers are set up to accept parallel input and QL users may find that they need to purchase a serial to parallel converter (also known as a Centronics interface) in order to use a printer.</SPAN></P>
    
<P><SPAN style="font-style: italic;">Each driver accepts various parameters which are used to match the output with the type expected by the device connected to the port. The main parameter deals with the parity of the byte to be sent. If no parity is specified, then all eight bits of the given byte will be sent, otherwise bit 7 of the byte will be altered according to the parity (this is best set according to what the hardware attached to the port requires).</SPAN></P>
    
<P><SPAN style="font-style: italic;">You can also specify whether handshake is to be enabled, which tells the computer whether to wait for confirmation from the external hardware that the data has been received safely. If handshake is enabled, then if no acknowledgement is received, or the external hardware reports an error then the computer will try again.</SPAN></P>
    
<P><SPAN style="font-style: italic;">Finally, you can specify whether the data is to be converted as it passes through the port. The standard code for ending a record or a line is CR, however, the QL is non-standard in that it uses the code LF, which therefore may need to be converted prior to transmitting.</SPAN></P>
    
<P><SPAN style="font-style: italic;">Also, you may wish to send the character &lt;CTRL&gt;&lt;Z&gt; as the last character in order to tell the external hardware that there is no more data.</SPAN></P>
    
<H3><SPAN style="font-style: italic;">Parallel Port (PAR)<BR></SPAN></H3>
    
<P><SPAN style="font-style: italic;">Syntax: <SPAN style="font-style: italic;">PAR</SPAN>&lt;<SPAN style="font-style: italic;">new_line</SPAN>&gt;&lt;<SPAN style="font-style: italic;">trns</SPAN>&gt;&lt;<SPAN style="font-style: italic;">ff</SPAN>&gt;&lt;<SPAN style="font-style: italic;">buf</SPAN>&gt;<SPAN style="font-style: italic;">(THOR XVI)</SPAN></SPAN></P>
    
<P>or <SPAN style="font-style: italic;">PAR</SPAN>&lt;<SPAN style="font-style: italic;">port</SPAN>&gt;&lt;<SPAN style="font-style: italic;">translate</SPAN>&gt;&lt;<SPAN style="font-style: italic;">convert</SPAN>&gt;&lt;<SPAN style="font-style: italic;">eof</SPAN>&gt;</P>
    
<P><SPAN style="font-style: italic;">(SMSQ/E, ST Emulators, Super Gold Card)</SPAN></P>
    
<P>or <SPAN style="font-style: italic;">PAR</SPAN> <SPAN style="font-style: italic;">(AMIGA QDOS)</SPAN>
    Location: <SPAN style="font-style: italic;">THOR XVI, ST Emulators, SMSQ/E, Super Gold Card, Amiga QDOS Emulator</SPAN></P>
    
<P>Various QL implementations now come equipped with a parallel device driver for use with their parallel port. Parallel ports can be used for transmitting data only and are therefore normally used to connect parallel printers to the computer. Although there are various other expansion boards which also provide the standard QL with a <SPAN style="font-style: italic;">PAR</SPAN> device, we do not currently have details of their syntax.</P>
    
<P>Note that even with SMSQ/E the <SPAN style="font-style: italic;">PAR</SPAN> device does not exist on a Gold Card - there is no parallel printer port!!</P>
    
<P>The syntax of this device is quite complex, allowing different types of translations and buffers to be used. We shall therefore examine each variant in turn.</P>
    
<H3>THOR XVI</H3>

<P>
    
<P>The values of each part of the device name are as follows:</P>
    
<P>&lt;<SPAN style="font-style: italic;">new_line</SPAN>&gt;This dictates how end of line (LFs) and end of text markers are to be treated. The following values are available:</P>
    <UL>
      <LI><SPAN style="font-style: italic;">n</SPAN> - This converts LF to CR,LF and sends &lt;CTRL&gt;&lt;Z&gt; at the end of the file. This is the default.</LI>
      <LI><SPAN style="font-style: italic;">c</SPAN> -This converts LF to CR and also sends &lt;CTRL&gt;&lt;Z&gt; at the end of the file.</LI>
      <LI><SPAN style="font-style: italic;">r</SPAN> -This sends the text as it is - no conversions are carried out.</LI>
      <LI><SPAN style="font-style: italic;">z</SPAN> - This does not convert LF, but sends &lt;CTRL&gt;&lt;Z&gt; at the end of the file.</LI>
    </UL>
    
<P>The following table may be of use:</P><!-- Old stuff, just in case...
<p>                       EOL
</p>
<p>| CR,LF|  CR| LF
</p>
<p> =====+=======+=====+=====
</p>
<p>   none|   -|  -|  <span style="font-style: italic;">r
</span></p>
<p>EOF   =====+=======+=====+=====
</p>
<p> CTRL-Z|  <span style="font-style: italic;"> n</span> |  <span style="font-style: italic;">c</span> |  <span style="font-style: italic;">z
</span></p>
<p>   =====+=======+=====+=====
</p>
-->
    <TABLE>
      <TR align="left">
        <TH>EOL</TH>
        <TH>EOF</TH>
        <TH>Use This</TH>
      </TR>
      <TR>
        <TD>CR,LF</TD>
        <TD>CTRL-Z</TD>
        <TD align="center">n</TD>
      </TR>
      <TR>
        <TD>CR</TD>
        <TD>CTRL-Z</TD>
        <TD align="center">c</TD>
      </TR>
      <TR>
        <TD>-</TD>
        <TD>-</TD>
        <TD align="center">r</TD>
      </TR>
      <TR>
        <TD>LF</TD>
        <TD>CTRL-Z</TD>
        <TD align="center">z</TD>
      </TR>
    </TABLE>
    
<P>&lt;<SPAN style="font-style: italic;">trns</SPAN>&gt;This tells the THOR XVI whether or not to use its translation tables (set with <SPAN style="font-style: italic;">TRA</SPAN>). This can have the following values:</P>
    <UL>
      <LI><SPAN style="font-style: italic;">t</SPAN> -Use the translation table. This is the default if &lt;<SPAN style="font-style: italic;">new_line</SPAN>&gt; is specified but not raw.</LI>
      <LI><SPAN style="font-style: italic;">p</SPAN> -Do not use translation table. This is the default if &lt;<SPAN style="font-style: italic;">new_line</SPAN>&gt; is not specified or is raw.</LI>
    </UL>
    
<P>&lt;<SPAN style="font-style: italic;">ff</SPAN>&gt;This says whether or not to send FF at the end of the file. The default depends on &lt;<SPAN style="font-style: italic;">new_line</SPAN>&gt;. By default, a FF will be sent if &lt;<SPAN style="font-style: italic;">new_line</SPAN>&gt; is set to <SPAN style="font-style: italic;">n</SPAN> or <SPAN style="font-style: italic;">c</SPAN> and the last character is not FF. The default can be overridden by setting &lt;<SPAN style="font-style: italic;">ff</SPAN>&gt; to <SPAN style="font-style: italic;">f</SPAN> which tells the THOR not to send FF unless of course there is already a FF at the end of the text!</P>
    
<P>&lt;<SPAN style="font-style: italic;">buf</SPAN>&gt;This sets the size of the output buffer in bytes, and must be in the form <SPAN style="font-style: italic;">_n</SPAN>, where <SPAN style="font-style: italic;">n</SPAN> is the size of the buffer. If you add '<SPAN style="font-style: italic;">k</SPAN>' after the value of <SPAN style="font-style: italic;">n</SPAN>, the value of n will be multiplied by 1024, for example <SPAN style="font-style: italic;">_2K</SPAN> sets an output buffer of 2048 bytes.</P>
    
<P>The default is <SPAN style="font-style: italic;">_127</SPAN>.</P>
    
<H3>Examples:</H3>

<P>
    
<P><SPAN style="font-style: italic;">par_90k</SPAN> Conversion of LF to CR, LF; translation table used; FF sent at end; buffer length 90 kilobytes.</P>
    
<P><SPAN style="font-style: italic;">parrt</SPAN> No conversion; translation table used; no FF sent.</P>
    
<P>Note the coupling between the &lt;<SPAN style="font-style: italic;">New_line</SPAN>&gt; and &lt;<SPAN style="font-style: italic;">trns</SPAN>&gt; arguments. This means that <SPAN style="font-style: italic;">par</SPAN> is equal to <SPAN style="font-style: italic;">parnt</SPAN>, whereas <SPAN style="font-style: italic;">parr</SPAN> is equal to <SPAN style="font-style: italic;">parrp</SPAN>. The translation table used is the one set with <SPAN style="font-style: italic;">TRA</SPAN>.</P>
    
<P>Default Device: <SPAN style="font-style: italic;">PARnt_128</SPAN></P>
    
<H3><SPAN style="font-style: italic;">ST EMULATORS, SUPER GOLD CARD AND SMSQ/E<BR></SPAN></H3>
    
<P><SPAN style="font-style: italic;">These allow output through the parallel ports to be buffered dynamically, whereby a buffer is allocated up to all of the available free memory or (except on the Super Gold Card without SMSQ/E) can be set to a specific amount of space (thus allowing printing to continue in the background). Several channels may be open to one output port at any time, in which case the data is buffered and sent through the parallel port in the order in which the channels are opened.</SPAN></P>
    
<P><SPAN style="font-style: italic;">Commands are implemented to allow you to set a specific output buffer or input buffer size (<SPAN style="font-style: italic;">PAR_BUFF</SPAN>), as well as aborting output to a parallel port (<SPAN style="font-style: italic;">PAR_ABORT</SPAN>) or clearing an output buffer (<SPAN style="font-style: italic;">PARR_CLEAR</SPAN>).</SPAN></P>
    
<P>The values of each part of the device name are as follows:</P>
    
<P>&lt;<SPAN style="font-style: italic;">port</SPAN>&gt;This is provided for future compatability. It represents the number of the parallel port to use. It can be either 1 or 2, although any attempt to use par2 is currently ignored and par1 used. The default is therefore 1.</P>
    
<P>&lt;<SPAN style="font-style: italic;">translate</SPAN>&gt;This, like the THOR XVI's &lt;trans&gt; parameter specifies the type of translation to be carried out on the data. This can have the following values:</P>
    <UL>
      <LI>d - No translation is performed.</LI>
      <LI>t - Translate according to the translate table. This is the default.</LI>
      <LI>&lt;<SPAN style="font-style: italic;">convert</SPAN>&gt;This specifies how LF is to be treated. It can have the values:
        <UL>
          <LI>c - This converts LF to CR.</LI>
          <LI>r - No conversion, this is the default.</LI>
          <LI>a -Insert CR,LF at end of line. Insert CR,FF at end of page (added to ST/QL drivers in Level D-05).</LI>
        </UL>
      </LI>
      <LI>&lt;<SPAN style="font-style: italic;">eof</SPAN>&gt;This specifies how the end of the file is to be treated. It can be the default (do nothing) or have one of the following values:
        <UL>
          <LI>f - Print FF at end of file</LI>
          <LI>z - Print CTRL-Z at end of file</LI>
        </UL>
      </LI>
    </UL>
    
<H3><SPAN style="font-style: italic;">Example:<BR></SPAN></H3>
    
<P><SPAN style="font-style: italic;">PAR1cz</SPAN> is the same as the THOR's <SPAN style="font-style: italic;">PARn</SPAN></P>
    
<P><SPAN style="font-style: italic;">Default Device: <SPAN style="font-style: italic;">PAR1tr</SPAN></SPAN></P>
    
<H3><SPAN style="font-style: italic;">AMIGA-QDOS<BR></SPAN></H3>
    
<P><SPAN style="font-style: italic;">This is the simplest form of parallel device driver, in that it does not accept any parameters (at least in v1.03 of the parallel driver). Any characters are sent straight through the Amiga's parallel port without being altered in any way.</SPAN></P>
    
<H3><SPAN style="font-style: italic;">Serial Ports (SER)<BR></SPAN></H3>
    
<P><SPAN style="font-style: italic;">Syntax: <SPAN style="font-style: italic;">SER</SPAN>&lt;<SPAN style="font-style: italic;">prt</SPAN>&gt;&lt;<SPAN style="font-style: italic;">par</SPAN>&gt;&lt;<SPAN style="font-style: italic;">handshake</SPAN>&gt;&lt;<SPAN style="font-style: italic;">protocol</SPAN>&gt;(QL only)</SPAN></P>
    
<P>or <SPAN style="font-style: italic;">SER</SPAN>&lt;<SPAN style="font-style: italic;">prt</SPAN>&gt;&lt;<SPAN style="font-style: italic;">par</SPAN>&gt;&lt;<SPAN style="font-style: italic;">hand</SPAN>&gt;&lt;<SPAN style="font-style: italic;">translate</SPAN>&gt;&lt;<SPAN style="font-style: italic;">convert</SPAN>&gt;&lt;<SPAN style="font-style: italic;">eof</SPAN>&gt;</P>
    
<P>(ST Emulators, SMSQ/E)</P>
    
<P>or <SPAN style="font-style: italic;">SER</SPAN>&lt;<SPAN style="font-style: italic;">prt</SPAN>&gt;&lt;<SPAN style="font-style: italic;">par</SPAN>&gt;&lt;<SPAN style="font-style: italic;">bits</SPAN>&gt;&lt;<SPAN style="font-style: italic;">hds</SPAN>&gt;&lt;<SPAN style="font-style: italic;">bpso</SPAN>&gt;&lt;<SPAN style="font-style: italic;">bpsi</SPAN>&gt;&lt;<SPAN style="font-style: italic;">nl</SPAN>&gt;&lt;<SPAN style="font-style: italic;">trns</SPAN>&gt;&lt;<SPAN style="font-style: italic;">ff</SPAN>&gt;&lt;<SPAN style="font-style: italic;">buf</SPAN>&gt;</P>
    
<P>(THOR XVI only)</P>
    
<P>Location: QL ROM, ST/QL, THOR XVI</P>
    
<P>The QL, and THOR XVI are each equipped with two serial ports, marked <SPAN style="font-style: italic;">SER1</SPAN> and <SPAN style="font-style: italic;">SER2</SPAN> on the rear panel. Other implementations of the QL can in fact have access to up to four serial ports (even the standard QL can use additional serial ports built into SuperHermes for example).</P>
    
<P>If only one serial port is available (as on some STs), any attempt to use <SPAN style="font-style: italic;">SER2</SPAN> is treated as <SPAN style="font-style: italic;">SER1</SPAN>.</P>
    
<P>The Amiga-QL emulator adopts a serial driver based on the JS version of the QL driver. It can be used to access either of the Amiga's two serial ports. It is however, unknown if current versions of the emulator's driver (v1.03) support CTRL Z.</P>
    
<P>Both ports on the British QL use non-standard British Telecom connectors and are actually wired up differently to each other (although they still use the same device driver). The other types of serial port tend to use standard 9-pin trapezium connectors.</P>
    
<P>On the standard QL, both ports conform with the RS-232-C standard, although the port marked <SPAN style="font-style: italic;">SER1</SPAN> is configured as a data communication equipment (DCE) port, which is normally used to drive printers; whereas the port marked <SPAN style="font-style: italic;">SER2</SPAN> is set up as a data terminal equipment (DTE) port, which is more suited towards accepting input from other devices (such as a modem). Refer to the QL User Guide manual, Concepts section, for further details of the hardware.</P>
    
<P>The rate at which data can be passed through the ports is known as the Baud rate which is set with the command <SPAN style="font-style: italic;">BAUD</SPAN> from SuperBasic (or with a corresponding machine code trap call). This is supposed to be the number of bits per second, but due to the limitations of the QL's hardware, the rate of data transfer actually falls somewhat short of these rates (unless you have a THOR XVI, or use Minerva or SMSQ/E which has speeded up the rate of data transfer considerably).</P>
    
<P>Unfortunately, the 8049 IPC which controls input from both serial ports on the QL cannot handle different baud rates for the two ports. On the other hand, the THOR XVI does support different baud rates, although not via the <SPAN style="font-style: italic;">BAUD</SPAN> command which sets the baud rate on both ports to the same. Hermes is a replacement for the QL's 8049 chip and allows different input baud rates on each of the two serial ports. Minerva allows different output baud rates on each port.</P>
    
<P>SMSQ/E and the ST Emulators allow you to set fully independent input and output <SPAN style="font-style: italic;">BAUD</SPAN> rates on each port (although SuperHermes is still needed if this is to work on a standard QL).</P>
    
<P>Either port may be used for input or output (subject to hardware restrictions - see above), however, only one channel can be open to a serial port at a time, and if a channel is already open to the given port, the error 'In Use' will be reported.</P>
    
<P>The actual implementation of the <SPAN style="font-style: italic;">SER</SPAN> device driver is dependent upon the machine. We shall therefore deal with each machine in turn.</P>
    
<H3>STANDARD QL</H3>

<P>
    
<P>This enables you to open a channel to either of the two serial ports. The action taken by the device driver depends both upon the ROM version being used and whether data is being input or output.</P>
    
<P>Note that input through the serial ports tends to be unreliable with baud rates in excess of 1200, and in any case, when receiving at 9600 baud, two stop bits must be issued by the transmitting device. Receiving at 19200 baud is not possible.</P>
    
<P>Unfortunately, problems in the 8049 mean that incoming data can be lost due to a delay in notification of the fact that the receive queue is full. Also, input channels can actually suffer from 'serial overrun' where some characters are held up in the 8049, and then released only when a new character is read from the serial port. This can sometimes happen with modems, making serial input unuseable.</P>
    
<P>There exists a replacement for the 8049 (called HERMES and its bigger brother SuperHERMES) which fixes these problems, as well as allowing separate baud rates for input and output channels, and which even supports different input rates on <SPAN style="font-style: italic;">SER1</SPAN> and <SPAN style="font-style: italic;">SER2</SPAN>. This replacement also makes input at the higher baud rates much more reliable (including input at 19200 baud), without needing two stop bits at any rate.</P>
    
<P>The handling of both input and output is also dependent upon the ROM version being used:</P>
    
<H3>(a) Output SERial devices</H3>

<P>
    
<P>Pre-JS ROMs:</P>
    
<P>If the C protocol has been chosen, then if the byte is a LF it is converted into a CR. Bit 7 of the byte is then adjusted to suit the parity and the byte then placed into the queue for the 8302 chip to read, deal with the handshaking and send through the channel. When the whole of the data has been sent, once the 8302 has emptied the queue, CTRL-Z is sent (if required).</P>
    
<P>Unfortunately, this meant that the protocol could just about be altered before the CTRL-Z had actually been sent, resulting in a failure by the QL to send any CTRL-Z's. This could happen for instance, if a series of small CTRL-Z files was sent to the serial channel and then the channel was re-opened as <SPAN style="font-style: italic;">SERr</SPAN>. Another problem with the handling of CTRL-Z's was that the parity (if required) was not always correct on this final byte.</P>
    
<P>JS and MG ROMs:</P>
    
<P>The serial driver followed the same pattern, except that if enabled by a <SPAN style="font-style: italic;">TRA</SPAN> command (or the appropriate machine code call) the byte was translated according to the specified translation table after it had been adjusted to suit the parity (if required). This meant that bytes above CHR$(127) could not always be translated. The problems with CTRL-Z persisted.</P>
    
<P>Minerva ROMs:</P>
    
<P>The serial driver is much improved, in that if the protocol is C, then LF is swapped with CR (and vice-versa). The byte is then translated according to the translation table (if required) and only then is it altered according to the parity setting.</P>
    
<P>The byte is then put into the queue to be sent to the 8302 and handshaking is then dealt with, leaving the 8302 to actually output the byte.</P>
    
<P>The problems with CTRL-Z have mainly been dealt with, although to overcome the problem of changing protocols, a channel structure linked to <SPAN style="font-style: italic;">SERz</SPAN> or <SPAN style="font-style: italic;">SERc</SPAN> cannot be discarded until all of the data in the transmit queue has been sent (meaning that the channel structure may not ever be discarded if handshaking forces the computer to keep trying to send the data). The main remaining problem is that in Minerva's two screen mode, characters may be lost on output.</P>
    
<H3>(b) Input SERial devices</H3>

<P>
    
<P>Pre-JS ROMs:</P>
    
<P>The 8302 deals with handshaking and then puts the byte which it has read into the receive queue. The device driver then reads the byte from the receive queue and checks the parity of the byte; reporting Xmit error if the check fails.</P>
    
<P>If the C protocol is chosen, then any CRs are converted into LFs and the byte returned to the user. Parity is completely ignored on CTRL-Z.</P>
    
<P>JS and MG ROMs:</P>
    
<P>These both still suffer from CTRL-Z.</P>
    
<P>If enabled, a simple (one to one) translate is performed on the incoming byte as soon as it is fetched from the receive queue (see <SPAN style="font-style: italic;">TRA</SPAN>). The parity is then altered as required, CRs converted into LFs (if necessary) and the byte passed onto the user.</P>
    
<P>Minerva ROMs:</P>
    
<P>This checks the parity on CTRL-Z if required, along with the parity on any other data as soon as each byte is fetched from the receive queue. The byte is then translated (if necessary) according to the simple (one to one) translation table, CRs and LFs exchanged (unless protocol R chosen) and the byte then passed onto the user.</P>
    
<H3>(c) The Standard QL Device Driver</H3>

<P>
    
<P>The parts of the device driver are made up of the following:</P>
    
<P>&lt;<SPAN style="font-style: italic;">prt</SPAN>&gt;This specifies which serial port is to be used, and can be 1 or any higher number.</P>
    
<P>The default is ser1.</P>
    
<P>&lt;<SPAN style="font-style: italic;">par</SPAN>&gt;This sets the type of parity to be used. The default is none, which allows all 8 bits of the characters to be sent. &lt;<SPAN style="font-style: italic;">par</SPAN>&gt; may however be specified for one of the following values:</P>
    <UL>
      <LI>e - Even</LI>
      <LI>o - Odd</LI>
      <LI>m - Mark</LI>
      <LI>s - Space</LI>
    </UL>
    
<P>If a parity setting is used, then only seven bits of each code sent to the serial port are used, the last eighth bit is used to specify the parity.</P>
    
<P>If the parity is wrong when data is received through a port then the error 'Xmit Error' is reported.</P>
    
<P>&lt;<SPAN style="font-style: italic;">handshake</SPAN>&gt;This specifies whether handshaking should be used. It may have the values:</P>
    <UL>
      <LI>i - Ignore Handshaking</LI>
      <LI>h - Handshaking on. This is the default.</LI>
    </UL>
    
<P>Handshaking is used to ensure that data is only sent through the serial port when the machine connected to the other end of the lead has sent a signal to say that it is ready to receive data.</P>
    
<P>&lt;<SPAN style="font-style: italic;">protocol</SPAN>&gt;This specifies the type of conversion to be used. It may have one of the following values:</P>
    <UL>
      <LI>r - No conversion carried out. This is the default.</LI>
      <LI>z - Use CTRL-Z for end of file flag.</LI>
      <LI>c - Convert LF to CR (or vice versa on input) and use CTRL-Z as end of file flag. Note: on Minerva, swap LF with CR on both input and output.</LI>
    </UL>
    
<P>Default Device: <SPAN style="font-style: italic;">SER1hr</SPAN></P>
    
<H3><SPAN style="font-style: italic;">ST EMULATORS AND SMSQ/E<BR></SPAN></H3>
    
<P><SPAN style="font-style: italic;">These support a slightly enhanced variant of the device found in JS and MG ROM QLs (but with different bugs). Output through the serial ports can be buffered dynamically, whereby a buffer is allocated up to all of the available free memory or can be set to specific amount of space (thus allowing printing to continue in the background). Several channels may be open to one output port at any time, in which case the data is buffered and sent through the serial port in the order in which the channels are opened.</SPAN></P>
    
<P><SPAN style="font-style: italic;">Commands are implemented to allow you to set a specific output buffer or input buffer size (<SPAN style="font-style: italic;">SER_BUFF</SPAN> and <SPAN style="font-style: italic;">SER_ROOM</SPAN>), as well as aborting output to a serial port (<SPAN style="font-style: italic;">SER_ABORT</SPAN>) or clearing an output buffer (<SPAN style="font-style: italic;">SER_CLEAR</SPAN>). Even the default handshaking can be set with <SPAN style="font-style: italic;">SER_FLOW</SPAN>.</SPAN></P>
    
<P>Serial ports may even be joined together to form a Network (<SPAN style="font-style: italic;">SERNET</SPAN>).</P>
    
<P>When using SMSQ/E on standard QL serial ports hardware, there are several ways to improve the reliability:</P>
    <OL>
      <LI>Use <SPAN style="font-style: italic;">STX</SPAN> instead of <SPAN style="font-style: italic;">SER</SPAN> to open output only ports.</LI>
      <LI>Use the command <SPAN style="font-style: italic;">SER_PAUSE</SPAN> to alter the length of the stop bits on the serial ports.</LI>
      <LI>Fit Hermes (or SuperHERMES) - this is especially important for using higher <SPAN style="font-style: italic;">BAUD</SPAN> rates and can improve the XON / XOFF protocol which can normally fail when trying to read data on the QL at over 2400 <SPAN style="font-style: italic;">BAUD</SPAN> or trying to send data at over 4800 <SPAN style="font-style: italic;">BAUD</SPAN>. Hermes is also needed to receive data at a different BAUD rate on each port and also at a different rate to the transmission rate.</LI>
      <LI>Change your serial to parallel converter - SMSQ/E is now so fast on the QL that some older converters no longer work correctly.</LI>
    </OL>
    
<P>The <SPAN style="font-style: italic;">SER</SPAN> device supports the various settings detailed on the following page. The default is <SPAN style="font-style: italic;">ser1htr</SPAN></P>
    
<P><SPAN style="font-style: italic;">&lt;<SPAN style="font-style: italic;">prt</SPAN>&gt;This is the same as on the QL.</SPAN></P>
    
<P>&lt;<SPAN style="font-style: italic;">par</SPAN>&gt;This is also the same as on the QL.</P>
    
<P>&lt;<SPAN style="font-style: italic;">hand</SPAN>&gt;This specifies whether or not to use handshaking, and if so which type is to be used. It can take the following values:</P>
    <UL>
      <LI>h - Hardware Handshaking on - the default.</LI>
      <LI>i - Ignore handshaking</LI>
      <LI>x - XON/XOFF; no handshaking (see <SPAN style="font-style: italic;">SER_ROOM</SPAN>).</LI>
    </UL>
    
<P>Hardware Handshaking can only be used with a five-wire serial connector, as it uses one of the lines as a signal line to signify when the machine is ready to receive data.</P>
    
<P>XON/XOFF was added to ST/QL Emulators in Level D-00 drivers and also exists in SMSQ/E - it is software based handshaking and can be used with three-wire serial connectors. An XOFF character is sent to the other machine when there are only 32 characters left in the receive buffer (or other figure set with <SPAN style="font-style: italic;">SER_ROOM</SPAN>), telling that other machine to stop sending data. Once there is room in the receive buffer for twice this number of characters an XON character is sent to the other machine which tells that machine to re- start data transmission.</P>
    
<P><SPAN style="font-style: italic;">SER_FLOW</SPAN> also affects this parameter.</P>
    
<P>&lt;<SPAN style="font-style: italic;">translate</SPAN>&gt;This specifies the type of translation to be carried out on the data. This can have the following values:</P>
    <UL>
      <LI>d - No translation is performed.</LI>
      <LI>t - Translate according to the translation table. This is the default.</LI>
    </UL>
    
<P>The <SPAN style="font-style: italic;">TRA</SPAN> command sets up translation tables.</P>
    
<P>&lt;<SPAN style="font-style: italic;">convert</SPAN>&gt;This specifies how LF is to be treated. It can have the values:</P>
    <UL>
      <LI>c - This converts LF to CR.</LI>
      <LI>r - No conversion, this is the default.</LI>
      <LI>a -Automatic insertion of CR,LF at end of line and CR,FF at end of page. This was added to ST/QL Drivers in Level D-05.</LI>
    </UL>
    
<P>&lt;<SPAN style="font-style: italic;">eof</SPAN>&gt;This specifies how the end of the file is to be treated. It can be the default (do nothing) or have one of the following values:</P>
    <UL>
      <LI>f - Print FF at end of file</LI>
      <LI>z - Print CTRL-Z at end of file</LI>
    </UL>
    
<H3>THOR XVI</H3>

<P>
    
<P>The serial ports provided on the THOR XVI use a much enhanced variant of the original JS device driver. The new serial device syntax is upwardly compatible with the original, ie. the old syntax described above is still accepted but additional parameters are allowed. The THOR also supports an enhanced translate table (see <SPAN style="font-style: italic;">TRA</SPAN>).</P>
    
<P>The following parameters are now accepted by the device driver:</P>
    
<P>&lt;<SPAN style="font-style: italic;">prt</SPAN>&gt;This is the same as on the standard QL driver.</P>
    
<P>&lt;<SPAN style="font-style: italic;">par</SPAN>&gt; Again, as per the standard QL.</P>
    
<P>&lt;<SPAN style="font-style: italic;">bits</SPAN>&gt;This digit sets the number of bits per byte to be sent. It can be 5, 6, 7 or 8. The default is 7 if parity is set, otherwise 8 for no parity.</P>
    
<P>&lt;<SPAN style="font-style: italic;">hds</SPAN>&gt;This letter sets handshaking:</P>
    <UL>
      <LI>h - on (default).</LI>
      <LI>i - ignore.</LI>
      <LI>x - XON/XOFF with handshaking.</LI>
      <LI>y - XON/XOFF without handshaking.</LI>
    </UL>
    
<P>&lt;<SPAN style="font-style: italic;">bpso</SPAN>&gt;This sets the current output baud rate and is specified as the number is preceded by a B. Valid parameters are: <SPAN style="font-style: italic;">
    B75</SPAN>, <SPAN style="font-style: italic;">B110</SPAN>, <SPAN style="font-style: italic;">B134.5</SPAN>, <SPAN style="font-style: italic;">B150</SPAN>, <SPAN style="font-style: italic;">B300</SPAN>, <SPAN style="font-style: italic;">B600</SPAN>, <SPAN style="font-style: italic;">B1200</SPAN>, <SPAN style="font-style: italic;">B1800</SPAN>, <SPAN style="font-style: italic;">B2400</SPAN>, <SPAN style="font-style: italic;">B4800</SPAN>, <SPAN style="font-style: italic;">B9600</SPAN>, <SPAN style="font-style: italic;">B19200</SPAN>.</P>
    
<P>The system <SPAN style="font-style: italic;">BAUD</SPAN> setting is the default. See <SPAN style="font-style: italic;">BAUD</SPAN>.</P>
    
<P>&lt;<SPAN style="font-style: italic;">bpsi</SPAN>&gt;This sets the input baud rate as above. A THOR XVI can send and receive data at different speeds. The default input baud rate is the current output baud rate.</P>
    
<P>&lt;<SPAN style="font-style: italic;">nl</SPAN>&gt;This letter specifies how the end of line (EOL) and end of file (EOF) codes should be converted. This is the same as &lt;<SPAN style="font-style: italic;">new_line</SPAN>&gt; in the THOR's PAR driver, except that the default here is r (raw).</P>
    
<P>&lt;<SPAN style="font-style: italic;">trns</SPAN>&gt;This tells the THOR XVI whether or not to use its translation tables (set with <SPAN style="font-style: italic;">TRA</SPAN>). This can have the following values:</P>
    <UL>
      <LI><SPAN style="font-style: italic;">t</SPAN> -Use the translation table. This is the default if &lt;<SPAN style="font-style: italic;">nl</SPAN>&gt; is not specified.</LI>
      <LI><SPAN style="font-style: italic;">p</SPAN> -Do not use translation table. This is the default if &lt;<SPAN style="font-style: italic;">nl</SPAN>&gt; is specified.</LI>
    </UL>
    
<P>&lt;<SPAN style="font-style: italic;">ff</SPAN>&gt;This says whether or not to send FF at the end of the file. The default depends on &lt;<SPAN style="font-style: italic;">nl</SPAN>&gt;. By default, a FF will be sent if &lt;<SPAN style="font-style: italic;">nl</SPAN>&gt; is set to <SPAN style="font-style: italic;">n</SPAN> or <SPAN style="font-style: italic;">c</SPAN> and the last character is not FF. The default can be overridden by setting &lt;<SPAN style="font-style: italic;">ff</SPAN>&gt; to <SPAN style="font-style: italic;">f</SPAN> which tells the THOR not to send FF unless of course there is already a FF at the end of the text!</P>
    
<P>&lt;<SPAN style="font-style: italic;">buf</SPAN>&gt;This sets the size of the output buffer in bytes, and must be in the form <SPAN style="font-style: italic;">_n</SPAN>, where <SPAN style="font-style: italic;">n</SPAN> is the size of the buffer. If you add '<SPAN style="font-style: italic;">k</SPAN>' after the value of <SPAN style="font-style: italic;">n</SPAN>, the value of n will be multiplied by 1024, for example <SPAN style="font-style: italic;">_2K</SPAN> sets an output buffer of 2048 bytes.</P>
    
<P>The default is <SPAN style="font-style: italic;">_127</SPAN>.</P>
    
<H3>Example 1:</H3>

<P>
    
<P><SPAN style="font-style: italic;">ser2exb75b1200cf</SPAN></P>
    
<P><SPAN style="font-style: italic;">ser2</SPAN> with even parity, send 7 bits per byte, XON/XOFF with handshake on, set output baud rate at 75 bps and input baud rate at 1200 bps, newline conversion to CR and use translate table, no form feed at end of file, use an output buffer of 127 bytes.</P>
    
<H3>Example 2:</H3>

<P>
    
<P><SPAN style="font-style: italic;">ser7b1200</SPAN></P>
    
<P><SPAN style="font-style: italic;">ser1</SPAN> with no parity, send 7 bits per byte, normal handshake, both output and input baud rate set at 1200, no newline conversion (raw data) but use translate table, send form feed at end of file, use output buffer of 127 bytes.</P>
    
<P>Default Device: <SPAN style="font-style: italic;">ser18hrt_127</SPAN></P>
    
<P>Note the coupling between the &lt;<SPAN style="font-style: italic;">nl</SPAN>&gt; and &lt;<SPAN style="font-style: italic;">trns</SPAN>&gt; arguments. This means that 'ser1' is equal to 'ser1rt', whereas 'ser1r' is equal to 'ser1rp'. The translation table used is the one set with <SPAN style="font-style: italic;">TRA</SPAN>.</P>
    
<H3>Serial Ports (SRX)</H3>

<P>
    
<P>Syntax: <SPAN style="font-style: italic;">SRX</SPAN>&lt;<SPAN style="font-style: italic;">prt</SPAN>&gt;&lt;<SPAN style="font-style: italic;">par</SPAN>&gt;&lt;<SPAN style="font-style: italic;">hand</SPAN>&gt;&lt;<SPAN style="font-style: italic;">translate</SPAN>&gt;&lt;<SPAN style="font-style: italic;">convert</SPAN>&gt;&lt;<SPAN style="font-style: italic;">eof</SPAN>&gt; Location: <SPAN style="font-style: italic;">ST Emulators, SMSQ/E</SPAN></P>
    
<P>This is a dedicated input only serial device, which has the same syntax as the ST Emulator's <SPAN style="font-style: italic;">SER</SPAN> device.</P>
    
<P>Default Device: <SPAN style="font-style: italic;">SRX1htr</SPAN></P>
    
<H3><SPAN style="font-style: italic;">Serial Ports (STX)<BR></SPAN></H3>
    
<P><SPAN style="font-style: italic;">Syntax: <SPAN style="font-style: italic;">STX</SPAN>&lt;<SPAN style="font-style: italic;">prt</SPAN>&gt;&lt;<SPAN style="font-style: italic;">par</SPAN>&gt;&lt;<SPAN style="font-style: italic;">hand</SPAN>&gt;&lt;<SPAN style="font-style: italic;">translate</SPAN>&gt;&lt;<SPAN style="font-style: italic;">convert</SPAN>&gt;&lt;<SPAN style="font-style: italic;">eof</SPAN>&gt; Location: <SPAN style="font-style: italic;">ST Emulators, SMSQ/E</SPAN></SPAN></P>
    
<P>This is a dedicated output only serial device, which has the same syntax as the ST Emulator's <SPAN style="font-style: italic;">SER</SPAN> device.</P>
    
<P>It is recommended that if your program only needs to be able to send data out of the serial ports, this device is used, as this will enable other programs to open input devices (<SPAN style="font-style: italic;">SRX</SPAN>) to the same serial port.</P>
    
<H3>NOTE:</H3>

<P>
    
<P>On a standard QL, the same hardware is used for both serial ports, and therefore if you are using one port for input and one for output you should use the <SPAN style="font-style: italic;">STX</SPAN> device on the output only port (instead of <SPAN style="font-style: italic;">SER</SPAN>). If you use <SPAN style="font-style: italic;">SER</SPAN> to open both ports then the speed of the input port will be unduly affected even though the other port is being used for output only. <SPAN style="font-style: italic;">STX</SPAN> gets around this problem.</P>
    
<P>Default Device: <SPAN style="font-style: italic;">STX1htr</SPAN></P>
    
<H3><SPAN style="font-style: italic;">Printer Ports (PRT)<BR></SPAN></H3>
    
<P><SPAN style="font-style: italic;">Syntax: <SPAN style="font-style: italic;">PRT</SPAN> Location: <SPAN style="font-style: italic;">Qjump RAMPRT, ST Emulators, SMSQ/E, QXL, Gold Card, Trump Card</SPAN></SPAN></P>
    
<P>This is an unusual device driver which comes in two forms. However, in both forms, the idea is that a user will set up this device to point to the port which connects to his printer, so that a program merely needs to OPEN prt. In practice however, it is more advisable to allow the user to configure the program with the details of the port to be used for printing.</P>
    
<H3>Qjump RAMPRT, Trump Card, QXL and Gold Cards</H3>

<P>
    
<P>These allow the <SPAN style="font-style: italic;">PRT</SPAN> device to be used to add buffers to serial and parallel ports (see <SPAN style="font-style: italic;">PRT_USE</SPAN>).</P>
    
<H3>ST Emulators and SMSQ/E</H3>

<P>
    
<P>On these implementations, the <SPAN style="font-style: italic;">PRT</SPAN> device can be used to emulate either <SPAN style="font-style: italic;">SER</SPAN> or <SPAN style="font-style: italic;">PAR</SPAN>, but does not necessarily have a buffer attached. See <SPAN style="font-style: italic;">PRT_USE</SPAN>.</P>
    
<H3>Memory Driver (MEM)</H3>

<P>
    
<P>Syntax: <SPAN style="font-style: italic;">MEM_</SPAN>[<SPAN style="font-style: italic;">adr1</SPAN>[_<SPAN style="font-style: italic;">adr2</SPAN>]] <SPAN style="font-style: italic;">(IODev)</SPAN></P>
    
<P>or <SPAN style="font-style: italic;">MEM</SPAN>[<SPAN style="font-style: italic;">bufnr</SPAN>][<SPAN style="font-style: italic;">_buflen</SPAN>{<SPAN style="font-style: italic;">p</SPAN>|<SPAN style="font-style: italic;">t</SPAN>}] <SPAN style="font-style: italic;">(DIY Toolkit)</SPAN>
    Location: <SPAN style="font-style: italic;">MEM device (DIY Toolkit Vol N), IODev (System)</SPAN></P>
    
<P>The memory device allows you to access RAM memory directly via a device. This is functionally the same as <SPAN style="font-style: italic;">PEEK</SPAN>ing the values with any of <SPAN style="font-style: italic;">PEEK</SPAN>'s available variants (<SPAN style="font-style: italic;">PEEK$</SPAN>, <SPAN style="font-style: italic;">PEEK_F</SPAN> etc), but the latter only allows you to access the memory of the local machine.</P>
    
<P>The <SPAN style="font-style: italic;">MEM</SPAN> device on the other hand can be installed on a different machine connected via the Toolkit II fileserver, which allows you to use any device driver on a host machine through the <SPAN style="font-style: italic;">n</SPAN>&lt;<SPAN style="font-style: italic;">nr</SPAN>&gt;_ fileserver interface (see below).</P>
    
<P>Data can be read and written through a <SPAN style="font-style: italic;">MEM</SPAN> device to memory with all commands and functions that work on files as well, so that memory becomes a file.</P>
    
<P>The DIY <SPAN style="font-style: italic;">MEM</SPAN> device supports up to eight buffers of <SPAN style="font-style: italic;">buflen</SPAN> bytes in size for data transfer between program and memory. A buffer is specified by <SPAN style="font-style: italic;">bufnr</SPAN>, each buffer can be either temporary (<SPAN style="font-style: italic;">t</SPAN> suffix to buffer length) or permanent (<SPAN style="font-style: italic;">p</SPAN>). The file pointer needs to be explicitly set to the address location which you want to read from or write to.</P>
    
<P>IODev's <SPAN style="font-style: italic;">MEM</SPAN> device has a much different syntax. The two modifiers <SPAN style="font-style: italic;">adr1</SPAN> and <SPAN style="font-style: italic;">adr2</SPAN> are numbers which indicate the start address (offset zero): <SPAN style="font-style: italic;">1024*adr1+adr2</SPAN>.</P>
    
<P><SPAN style="font-style: italic;">adr1</SPAN> and <SPAN style="font-style: italic;">adr2</SPAN> are assumed zero if omitted.</P>
    
<H3>Example:</H3>

<P>
    
<P>The classical demonstration for the <SPAN style="font-style: italic;">MEM</SPAN> device is copying</P>
    
<P>the screen from one machine to another:</P>
    
<P>(1) IODev Variant</P>
    
<P>This can be easily done with:</P>
    
<P><SPAN style="font-style: italic;">SBYTES n2_mem_128,131072,32768</SPAN></P>
    
<P>provided that the screen address is located at 131072 (128 * 1024 = 131072) on both machines and that both screens are 32k long. The above command copies the screen of the current machine to Network station number 2 (which must be running <SPAN style="font-style: italic;">FSERVE</SPAN>).</P>
    
<P>(2) DIY Toolkit variant</P>
    
<P>This is defined differently and needs you to set the file pointer accordingly:</P>
    <PRE>100 SBYTES_O ram1_q,131072,32768
110 OPEN#3,n2_mem_
120 GET#3\131072
130 SPL ram1_q TO #3
</PRE>
    
<P>You will have noticed that both variants of <SPAN style="font-style: italic;">MEM</SPAN> have an incompatible syntax. Fortunately however, it is still possible to write portable programs for both devices. Just use the most basic syntax; both <SPAN style="font-style: italic;">MEM</SPAN>s will then behave identically and start at the absolute address zero.</P>
    
<P>This means that the above DIY Toolkit example will also work on the IODev variant (however ensure that the final underscore appears in line 110 to maintain DIY Toolkit compatability.</P>
    
<P>This example can be much improved by avoiding the need for a temporary file and extra code to check if <SPAN style="font-style: italic;">SPL</SPAN> has finished (ignored here) by using <SPAN style="font-style: italic;">FWRITE</SPAN>.</P>
    
<H3>NOTE:</H3>

<P>
    
<P><SPAN style="font-style: italic;">MEM</SPAN> could have problems on Minerva pre v1.78.</P>
    
<H3>WARNING:</H3>

<P>
    
<P>The use of the <SPAN style="font-style: italic;">MEM</SPAN> device is not recommended because it uses absolute addresses on another machine. QDOS tends to move around all kinds of area of memory, so that even very sophisticated communication between the network partners cannot provide enough safety to avoid crashes.</P>
    
<P>Imagine the following (horror) scenario: Machine 1 tells machine 2 where its screen memory is located. Machine 2 starts to send its own screen to machine 1 but during the upload QDOS moves the screen on machine 1 to another location... BANG! The use of <SPAN style="font-style: italic;">MEM</SPAN> must be declared as dirty or at least most dangerous. There are always alternatives which avoid <SPAN style="font-style: italic;">MEM</SPAN>.</P>
    
<H3>Network Drivers (NET)</H3>

<P>
    
<P>Syntax: <SPAN style="font-style: italic;">NET</SPAN>&lt;<SPAN style="font-style: italic;">direction</SPAN>&gt;&lt;<SPAN style="font-style: italic;">station</SPAN>&gt;<SPAN style="font-style: italic;">(QL ROM)</SPAN></P>
    
<P>or <SPAN style="font-style: italic;">NET</SPAN>&lt;<SPAN style="font-style: italic;">direction</SPAN>&gt;&lt;<SPAN style="font-style: italic;">station</SPAN>&gt;_&lt;<SPAN style="font-style: italic;">buffer</SPAN>&gt;<SPAN style="font-style: italic;">(Toolkit II, THOR XVI)</SPAN>
    Location: <SPAN style="font-style: italic;">QL ROM, Toolkit II, THOR XVI</SPAN></P>
    
<P>These device drivers are explained separately in the Networks appendix.</P>
    
<H3>Communication Drivers (PIPE)</H3>

<P>
    
<P>Syntax: <SPAN style="font-style: italic;">PIPE_length</SPAN><SPAN style="font-style: italic;">(standard drivers)</SPAN></P>
    
<P>or <SPAN style="font-style: italic;">PIPE</SPAN>[<SPAN style="font-style: italic;">IDin</SPAN>]{<SPAN style="font-style: italic;">X</SPAN> | <SPAN style="font-style: italic;">P</SPAN> | <SPAN style="font-style: italic;">T</SPAN>}<SPAN style="font-style: italic;">IDout</SPAN>[<SPAN style="font-style: italic;">_</SPAN>[<SPAN style="font-style: italic;">length</SPAN>]][<SPAN style="font-style: italic;">K</SPAN>]<SPAN style="font-style: italic;">(Minerva v1.97+)</SPAN></P>
    
<P>or <SPAN style="font-style: italic;">PIPE_name</SPAN>[<SPAN style="font-style: italic;">_length</SPAN>] <SPAN style="font-style: italic;">(named drivers, SMS)</SPAN>
    Location: <SPAN style="font-style: italic;">QL ROM, named pipe drivers, SMS</SPAN></P>
    
<P>These are basically areas of memory which are set aside to act as communication queues. In theory, output data can be placed into the queue by a Job through one channel and the data can then be read by another Job (or the same Job) through another channel. The Job which is outputting data will be told when the pipe is full and will have to wait for something else to read some of the data before any more can be placed into the pipe.</P>
    
<P>Data is read out of a pipe in the order in which it is placed into it. This is known as First In First Out (FIFO).</P>
    
<P>Pipes can only be one way (either output or input). Any attempt to send data through an input pipe (or to read data from an output pipe) will cause a 'Bad Parameter' error. For compatability reasons, you should open output pipes with <SPAN style="font-style: italic;">OPEN_NEW</SPAN> and open input pipes with <SPAN style="font-style: italic;">OPEN_IN</SPAN>.</P>
    
<P>A channel which is open to an input pipe cannot detect the end of data held within the pipe with the <SPAN style="font-style: italic;">EOF</SPAN> command (unless the output channel has been closed) - instead, you will need to use the <SPAN style="font-style: italic;">PEND</SPAN> or <SPAN style="font-style: italic;">EOFW</SPAN> command to check if there is any more data waiting in the pipe. If you do not do this, then commands accessing the input pipe will merely wait around until they timeout (or wait indefinitely if the timeout is negative!).</P>
    
<P>More recently, the concept of Named Pipes has been introduced to QDOS which make the handling of pipes much easier, as you only need supply the name of the pipe to the input channel.</P>
    
<P>Again, we need to look at the various implementations of pipes:</P>
    
<H3>STANDARD QL ROM</H3>

<P>
    
<H3>(1) Output Pipes.</H3>

<P>
    
<P>It is easy to open an output pipe, with the syntax:</P>
    
<P><SPAN style="font-style: italic;">PIPE_length</SPAN></P>
    
<P>where:</P>
    
<P><SPAN style="font-style: italic;">length</SPAN> Defines the length of the pipe, this is the number of bytes which can be stored in the queue at any one time. This cannot be extended at a later date (at least not very easily without losing all of the data).</P>
    
<P><SPAN style="font-style: italic;">length</SPAN> must be in the range 2...32767.</P>
    
<P>There is no default.</P>
    
<H3>(2) Input Pipes.</H3>

<P>
    
<P>The problem comes when you try to link an input channel to this pipe. To do this, you need to open a channel to <SPAN style="font-style: italic;">PIPE_0</SPAN> with the channel ID of the first pipe in the machine code register D3.</P>
    
<P>Unfortunately there is no easy way of doing this in SuperBASIC, unless you have Minerva v1.82+ (see <SPAN style="font-style: italic;">OPEN</SPAN>) or use a toolkit command such as <SPAN style="font-style: italic;">QLINK</SPAN> which connects an existing channel to the given pipe.</P>
    
<H3>WARNING:</H3>

<P>
    
<P>More than one input pipe may be connected to the same output pipe inadvertently, and you could even connect one input pipe to another. Both of these will eventually crash the system.</P>
    
<H3>MINERVA ROM</H3>

<P>
    
<P>This allows pipes to be created which are the same as on the standard QL ROM, except that <SPAN style="font-style: italic;">length</SPAN> can have the letter K appended to multiply it by 1024. However, it is easier to link up input pipes to existing output pipes by using the extended <SPAN style="font-style: italic;">OPEN</SPAN> commands implemented on Minerva v1.82+.</P>
    
<H3>Example:</H3>

<P>
    
<P>Open a pipe between two programs, with a buffer of 10K</P>
    <PRE>100 PCHAN=3
110 OPEN_NEW #PCHAN,pipe_10K
120 pipeID=PEEK_W(\48\PCHAN*40+2)
</PRE>
    
<P>then in another program, having transferred the pipeID from the above program (by example using a temporary file):</P>
    <PRE>130 OPEN_IN #5,pipe_,pipeID
</PRE>
    
<P>However, a more flexible type of pipe has been implemented in Minerva v1.93+, with the syntax:</P>
    
<P><SPAN style="font-style: italic;">PIPE</SPAN>[<SPAN style="font-style: italic;">IDin</SPAN>]{<SPAN style="font-style: italic;">X</SPAN> | <SPAN style="font-style: italic;">P</SPAN> | <SPAN style="font-style: italic;">T</SPAN>}<SPAN style="font-style: italic;">IDout</SPAN>[<SPAN style="font-style: italic;">_</SPAN>[<SPAN style="font-style: italic;">length</SPAN>]][<SPAN style="font-style: italic;">K</SPAN>]</P>
    
<P>Pipes are identified by ID numbers (<SPAN style="font-style: italic;">IDin</SPAN>) and (<SPAN style="font-style: italic;">IDout</SPAN>), both of which can be any integer number in the range -32768 to 32767. The effect of omitting either ID numbers depends on the circumstances (see below).</P>
    
<P>In keeping with the other pipe drivers, <SPAN style="font-style: italic;">length</SPAN> can be any integer between 0 ans 32767, appended by <SPAN style="font-style: italic;">K</SPAN> if you want to multiply it by 1024. If omitted, it defaults to 0.</P>
    
<P>This sets up a system of pipes which are very similar to named pipes and channels can actually be opened to pipes which can both read from and output data to that pipe. The first channel to open a pipe to a particular IDin or IDout will need to specify the buffer <SPAN style="font-style: italic;">length</SPAN> - any future channel which tries to specify a buffer <SPAN style="font-style: italic;">length</SPAN> for the same pipe IDin or IDout will have no effect on the buffer.</P>
    
<P>The effect of the pipe depends on the values of <SPAN style="font-style: italic;">IDin</SPAN>, <SPAN style="font-style: italic;">IDout</SPAN> and whether the <SPAN style="font-style: italic;">X</SPAN>, <SPAN style="font-style: italic;">P</SPAN> or <SPAN style="font-style: italic;">T</SPAN> parameter is specified.</P>
    <OL>
      <LI>If <SPAN style="font-style: italic;">IDin</SPAN> is omitted then the channel opened to the pipe will be write-only. <SPAN style="font-style: italic;">IDin</SPAN> defaults to zero.</LI>
      <LI>If <SPAN style="font-style: italic;">IDout</SPAN> is omitted or a negative number, and <SPAN style="font-style: italic;">IDin</SPAN> is specified together with the <SPAN style="font-style: italic;">X</SPAN>, <SPAN style="font-style: italic;">P</SPAN> or <SPAN style="font-style: italic;">T</SPAN> parameter then it will default to the same as <SPAN style="font-style: italic;">IDin</SPAN>. - see (3) below. However, If <SPAN style="font-style: italic;">IDout</SPAN> is omitted and the above paragraph does not apply, IDout is taken to be zero (or if <SPAN style="font-style: italic;">IDout</SPAN> is specified to be zero) then the channel opened to the pipe will be read-only (you will need to specify <SPAN style="font-style: italic;">X</SPAN>, <SPAN style="font-style: italic;">P</SPAN> or <SPAN style="font-style: italic;">
      T</SPAN> parameter if Minerva is to recognise <SPAN style="font-style: italic;">IDout</SPAN> whether it is there or not).</LI>
      <LI>If both <SPAN style="font-style: italic;">IDin</SPAN> and <SPAN style="font-style: italic;">IDout</SPAN> are non-zero (or <SPAN style="font-style: italic;">IDout</SPAN> was made to be the same as <SPAN style="font-style: italic;">IDin</SPAN> under (2) above), then the channel opened to the pipe will read data from IDin and send data to <SPAN style="font-style: italic;">IDout</SPAN>. If <SPAN style="font-style: italic;">IDin</SPAN> and <SPAN style="font-style: italic;">IDout</SPAN> are the same then this will form a circular queue.</LI>
      <LI>If both <SPAN style="font-style: italic;">IDin</SPAN> and <SPAN style="font-style: italic;">IDout</SPAN> are omitted and the <SPAN style="font-style: italic;">X</SPAN>, <SPAN style="font-style: italic;">P</SPAN> or <SPAN style="font-style: italic;">T</SPAN> parameter is not specified, then you have created a standard QL pipe! If you specify the <SPAN style="font-style: italic;">P</SPAN> or <SPAN style="font-style: italic;">T</SPAN> parameter in this instance, see note 1 and note 2 below. <SPAN style="font-style: italic;">PIPEX</SPAN> has no meaning!</LI>
      <LI>If a P parameter is specified, then this pipe will be marked as permanent and will retain its data even if no channels are open to it.</LI>
      <LI>A T parameter marks a pipe as temporary and can be used to remove a permanent pipe, eg:
      <SPAN style="font-style: italic;">OPEN #3,'pipe1p2'</SPAN>Open a permanent input pipe (ID=1) and a permanent output pipe (ID=2).
      <SPAN style="font-style: italic;">OPEN #3,'pipet2':CLOSE #3</SPAN>Remove the pipe (ID=2) once all information has been read from it.</LI>
      <LI>A X parameter is used to merely separate IDin and IDout - this will create a temporary pipe which will mark the end of the data 'End of File' when the last channel which can output data to the specified pipe ID has been closed. When there are no channels at all left open to that pipe ID then any data in that pipe is lost and the memory released.</LI>
    </OL>
    
<H3>Examples:</H3>

<P>
    
<P><SPAN style="font-style: italic;">OPEN #3,pipe3x_100</SPAN>Open a read only pipe with a 100 byte buffer.</P>
    
<P><SPAN style="font-style: italic;">OPEN #3,pipex3_100</SPAN>Open the write only end of the above pipe.</P>
    
<P>Any easy way to transfer data between two programs:</P>
    
<P>From SuperBASIC enter the program:</P>
    <PRE>100 OPEN #3,pipe1t3_300
110 REPeat wait_loop
120   INPUT #3,info$
130   IF info$='PROG 2 IS READY - SEND'
140     INPUT #3,datan,dummy$
150     EXIT wait_loop
160   END IF
170 END REPeat wait_loop
180 FOR i=1 TO datan
190   INPUT 'Enter Data Entry ';(i);': ';a$
200   PRINT #3,a$
210 END FOR i
220 REPeat end_WAIT
230   INPUT #3,a$
240   IF a$='THANKYOU':PRINT 'DATA SENT SUCCESSFULLY':EXIT end_WAIT
250 END REPeat end_WAIT
260 CLOSE #3
</PRE>
    
<P><SPAN style="font-style: italic;"><BR></SPAN>Use <SPAN style="font-style: italic;">EX pipep</SPAN> to start a MultiBASIC and enter the program:</P>
    <PRE>100 OPEN #3,pipe3t1_300
110 space=10
120 DIM rd$(space,100)
130 PRINT #3,'PROG 2 IS READY - SEND'
140 PRINT #3,space
150 PRINT #3,'DATA'
160 FOR i=1 TO space
170   INPUT #3,rd$(i)
180 END FOR i
190 PRINT #3,'THANKYOU'
200 CLOSE #3
</PRE>
    
<P>Now <SPAN style="font-style: italic;">RUN</SPAN> the program in the MultiBASIC, &lt;CTRL&gt;&lt;C&gt; to SuperBASIC and enter <SPAN style="font-style: italic;">RUN</SPAN>. Any data you enter into the SuperBASIC program will then be sent to the MultiBASIC program. Both programs can be <SPAN style="font-style: italic;">RUN</SPAN> in either order!!</P>
    
<H3>NOTE 1:</H3>

<P>
    
<P><SPAN style="font-style: italic;">PIPEP</SPAN> without any other parameters was implemented to automatically start up a MultiBasic, by using for example: <SPAN style="font-style: italic;">
    EX pipep</SPAN></P>
    
<P>see <SPAN style="font-style: italic;">EW</SPAN> for details.</P>
    
<H3>NOTE 2:</H3>

<P>
    
<P><SPAN style="font-style: italic;">PIPET</SPAN> opens a pipe similar to a <SPAN style="font-style: italic;">NUL</SPAN> device - any attempt to read data from it will always report 'End of File', whereas any data sent to it will be thrown away.</P>
    
<H3>NOTE 3:</H3>

<P>
    
<P>In v1.97 <SPAN style="font-style: italic;">PIPEP</SPAN> and <SPAN style="font-style: italic;">PIPET</SPAN> were the wrong way around when opened as an input pipe. You will therefore need to use a line such as:</P>
    
<P><SPAN style="font-style: italic;">IF VER$(1)='1.97' : OPEN_IN #3,PIPEP2 : ELSE : OPEN_IN #3,PIPET2</SPAN></P>
    
<H3><SPAN style="font-style: italic;">NOTE 4:<BR></SPAN></H3>
    
<P><SPAN style="font-style: italic;">It is recommended that in order to overcome problems with multitasking jobs trying to access the same pipe IDs inadvertantly, a Job should use its own Job number*100 plus the pipe ID number. This can be calculated with:</SPAN></P>
    
<P><SPAN style="font-style: italic;"><SPAN style="font-style: italic;">jobID=VER$(-1) : JobNr=JobID-INT(JobID/65536)*65536</SPAN></SPAN></P>
    
<P><SPAN style="font-style: italic;">JobID=(PEEK_L(!!100)-PEEK_L(!!104)) DIV 4</SPAN></P>
    
<H3><SPAN style="font-style: italic;"><BR></SPAN></H3>
    
<H3><SPAN style="font-style: italic;">NAMED PIPE DRIVERS, SMS<BR></SPAN></H3>
    
<P><SPAN style="font-style: italic;">SMS, the ST/QL Emulators (Level D-00 onwards) and various other utilities implement named pipe drivers.</SPAN></P>
    
<P><SPAN style="font-style: italic;">Named pipes solve many of the problems associated with QDOS's native pipes, in that there is no need to know the channel ID of the output pipe in order to open the input pipe.</SPAN></P>
    
<P><SPAN style="font-style: italic;">Most versions will also allow you to open the input side before opening the output side, but oddly enough some non- standard versions will lose any data stored in a pipe if there is neither an output nor an input channel associated with it.</SPAN></P>
    
<P><SPAN style="font-style: italic;">Input and output pipes can be closed in any order - information contained in them will not be lost, so you can close both the input and output pipes, but if there is still information contained in the pipe, you can then open a new input pipe to read this remaining data.</SPAN></P>
    
<P><SPAN style="font-style: italic;">SMS v2.79 has further extended the concept of named pipes, allowing you to <SPAN style="font-style: italic;">DELETE</SPAN> and <SPAN style="font-style: italic;">DIR</SPAN> pipes.</SPAN></P>
    
<P><SPAN style="font-style: italic;">DIR pipe</SPAN></P>
    
<P>will list all named pipes which exist</P>
    
<P><SPAN style="font-style: italic;">DELETE pipe_name</SPAN></P>
    
<P>will delete the specified pipe.</P>
    
<P>You can also <SPAN style="font-style: italic;">VIEW pipe_name</SPAN>.</P>
    
<P>In current drivers, a maximum of 15 or 16 named pipes can be open at any one time. The syntax of this driver is:</P>
    
<P><SPAN style="font-style: italic;">PIPE_name_length</SPAN> for an output pipe, or</P>
    
<P><SPAN style="font-style: italic;">PIPE_name</SPAN> for an input pipe.</P>
    
<P>where:</P>
    
<P><SPAN style="font-style: italic;">name</SPAN>The name of the pipe (up to 32766 characters long), which must be in the standard name format (ie. the first character must be a letter or '_' symbol, with any other characters following).</P>
    
<P>There is no default.</P>
    
<P><SPAN style="font-style: italic;">length</SPAN>The length of the queue associated with the pipe (ie. how many characters can be stored in the pipe at a time). This must be in the range 2...32767. If a length of zero is given, this is taken to be an input pipe.</P>
    
<P>Default is 0.</P>
    
<H3>NOTE 1:</H3>

<P>
    
<P>As there is no guarantee when you open an input channel to a pipe that it is empty (or contains only the information which you expect - for example another copy of your program may already be in use!!), it is normal for the first information to be sent by a program through a pipe to be some identification information (see the Minerva examples).</P>
    
<H3>Examples:</H3>

<P>
    
<P><SPAN style="font-style: italic;">OPEN_NEW #3,PIPE_100</SPAN></P>
    
<P>Open a standard output pipe which can hold up to 100 characters at a time.</P>
    
<P><SPAN style="font-style: italic;">OPEN_NEW #4,PIPE_xover_50</SPAN></P>
    
<P>Open an output pipe named <SPAN style="font-style: italic;">xover</SPAN> which can hold up to 50 characters at a time.</P>
    
<P><SPAN style="font-style: italic;">OPEN_IN #5,PIPE_xover</SPAN></P>
    
<P>Open an input channel to the pipe xover.</P>
    
<P><SPAN style="font-style: italic;">OPEN_NEW #2,PIPE_quill_exp_100</SPAN></P>
    
<P>Open an output pipe named quill_exp with a buffer for 100 characters.</P>
    
<P><SPAN style="font-style: italic;">PIPE_0</SPAN></P>
    
<P>Open a general input channel to a pipe - see standard QL version above!</P>
    
<H3>NOTE 2:</H3>

<P>
    
<P>Before Level D-06 of the ST/QL Drivers, PIPE_ or PIPE_0 could cause problems with TURBO compiled programs.</P>
    
<H3>WARNING:</H3>

<P>
    
<P>When using SMSQ/E's named pipes, if you try to <SPAN style="font-style: italic;">DELETE</SPAN> a pipe but a channel is <SPAN style="font-style: italic;">OPEN</SPAN> to that pipe, then the error 'in use' is reported. However, when all channels to that pipe are <SPAN style="font-style: italic;">CLOSE</SPAN>d, the pipe will immediately be <SPAN style="font-style: italic;">DELETE</SPAN>d.</P>
    
<H3>Communication Drivers (HISTORY)</H3>

<P>
    
<P>Syntax: <SPAN style="font-style: italic;">HISTORY_name</SPAN>[<SPAN style="font-style: italic;">_length</SPAN>]</P>
    
<P>or <SPAN style="font-style: italic;">HISTORY</SPAN>[<SPAN style="font-style: italic;">_length</SPAN>] Location: <SPAN style="font-style: italic;">SMSQ/E</SPAN></P>
    
<P>The first syntax to this device creates a Public History Device - this is similar to the named pipes driver on the SMSQ/E except that it works as a Last In First Out (LIFO) device, so that information read from a HISTORY appears in the opposite order to which it was placed in the HISTORY and can be read from any program. Also if a HISTORY device becomes full, the oldest message is thrown away. Messages are separated by NewLine characters.</P>
    
<P>Note that the <SPAN style="font-style: italic;">name</SPAN> should not be a single character to allow for future improvements to this device.</P>
    
<P>The second syntax creates a Private History Device, which still stores messages so that they are fetched out of the History in the reverse order to how they were stored. However, no other program will be able to open a channel to this History and therefore it can only be read by the program which has opened it.</P>
    
<P>In both versions, if <SPAN style="font-style: italic;">length</SPAN> is not specified, then it is presumed to be 1024 bytes.</P>
    
<P>As with Named Pipes, as from v2.79 of SMSQ/E, you can use <SPAN style="font-style: italic;">DIR</SPAN>, <SPAN style="font-style: italic;">VIEW</SPAN> and <SPAN style="font-style: italic;">DELETE</SPAN> to get a directory of Public Histories, look at one of them and Delete them.</P>
    
<H3>Example:</H3>

<P>
    
<P>Grab the name of the last file on a disk:</P>
    <PRE>OPEN_NEW #4,HISTORY_FILE_10000
DIR #4,flp1_

VIEW HISTORY_file: REMark Just a quick look at the contents - it does  not  alter  the  contents  of  the HISTORY

INPUT #4,name$
CLOSE #4
DIR HISTORY
DELETE HISTORY_file
</PRE>
    
<H3>Nul Driver (NUL)</H3>

<P>
    
<P>Syntax: <SPAN style="font-style: italic;">NUL</SPAN></P>
    
<P>or <SPAN style="font-style: italic;">NULZ</SPAN></P>
    
<P>or <SPAN style="font-style: italic;">NULF</SPAN></P>
    
<P>or <SPAN style="font-style: italic;">NULL</SPAN></P>
    
<P>or <SPAN style="font-style: italic;">NULP</SPAN> Location: <SPAN style="font-style: italic;">ST/QL Emulators and SMS</SPAN></P>
    
<P>A nul device is generally just an empty input only device that can consume anything put into it at great speed. It enables you to write software which can easily turn off its normal output by merely re-opening its output channel to a nul device should the user choose to do so.</P>
    
<P>All nul drivers are added by additional hardware and software. The standard device name is <SPAN style="font-style: italic;">NUL</SPAN>, but there are also <SPAN style="font-style: italic;">NULZ</SPAN>, <SPAN style="font-style: italic;">NULF</SPAN>, <SPAN style="font-style: italic;">NULL</SPAN> and <SPAN style="font-style: italic;">NULP</SPAN>.</P>
    
<H3>INPUT</H3>

<P>
    
<P>The only real difference is if you try to read one of the nul drivers.</P>
    <OL>
      <LI><SPAN style="font-style: italic;">NUL</SPAN> - This is an output only device, and returns bad parameter if you try to read information from it. Any attempt to read window information will return a zero parameter. Any attempt to read pointer information will return an invalid parameter.</LI>
      <LI><SPAN style="font-style: italic;">NULF</SPAN> - This emulates a null file - the <SPAN style="font-style: italic;">EOF</SPAN> function will always be true on this channel. If you read the file header (with <SPAN style="font-style: italic;">HGET</SPAN> for example) then a 14 byte header full of zeros is returned. Any attempt to read window information or pointer information has the same result as on <SPAN style="font-style: italic;">NUL</SPAN>.</LI>
      <LI><SPAN style="font-style: italic;">NULL</SPAN> - This emulates a file filled with Line Feed characters <SPAN style="font-style: italic;">CHR$(10)</SPAN>. The file position can be set anywhere and the file header is 14 zero bytes. Any attempt to read window information or pointer information has the same result as on <SPAN style="font-style: italic;">NUL</SPAN>.</LI>
      <LI><SPAN style="font-style: italic;">NULZ</SPAN> - This emulates a file full of zeros. You can set the file position to any value, but reading the header or data from the file will always return zeros. Any attempt to read window information or pointer information has the same result as on <SPAN style="font-style: italic;">NUL</SPAN>.</LI>
      <LI><SPAN style="font-style: italic;">NULP</SPAN> - This will force the program to wait forever (or until any specified timeout has elapsed).</LI>
    </OL>
    
<H3>OUTPUT</H3>

<P>
    
<P>There is no difference when writing - all of the drivers just forget any data sent to them (eating it up at very high speeds).</P>
    
<H3>A12.5 DIRECT SECTOR ACCESS</H3>

<P>
    
<P>All standard directory device drivers (WIN, FLP, MDV and RAM) support direct sector access. This allow you to access the contents of a directory device without having to rely on the directory itself - it can therefore be used to rescue corrupt disks and even change the formatting of a disk (for example one utility uses this feature to squeeze extra room onto a normal Double Density floppy disk).</P>
    
<P>To use direct sector access, it is necessary to <SPAN style="font-style: italic;">OPEN</SPAN> a channel to a special filename, in the form:</P>
    
<P><SPAN style="font-style: italic;">DRIVEn_*Dsd</SPAN></P>
    
<P>Where:</P>
    
<P><SPAN style="font-style: italic;">DRIVEn_</SPAN> This should be the name of the device followed by the drive number, for example <SPAN style="font-style: italic;">FLP1_</SPAN></P>
    
<P><SPAN style="font-style: italic;">*D</SPAN> This is the direct access identifier and must remain the same.</P>
    
<P><SPAN style="font-style: italic;">s</SPAN> This is a number which represents the length of a sector. <SPAN style="font-style: italic;">s</SPAN> should be one of the following numbers:</P>
    <UL>
      <LI><SPAN style="font-style: italic;">0</SPAN> = 128 bytes</LI>
      <LI><SPAN style="font-style: italic;">1</SPAN> = 256 bytes</LI>
      <LI><SPAN style="font-style: italic;">2</SPAN> = 512 bytes (DD and HD disks)</LI>
      <LI><SPAN style="font-style: italic;">3</SPAN> = 1024 bytes</LI>
      <LI><SPAN style="font-style: italic;">4</SPAN> = 2048 bytes (ED disks)</LI>
    </UL>
    
<P>The value of <SPAN style="font-style: italic;">4</SPAN> is only supported on Super Gold Cards. Values other than <SPAN style="font-style: italic;">2</SPAN> are only supported on SMSQ/E and ST/QL Drivers from Level D-05 onwards.</P>
    
<P><SPAN style="font-style: italic;">d</SPAN> This is a letter in lower case which represents the density of the device, and should be:</P>
    <UL>
      <LI><SPAN style="font-style: italic;">d</SPAN> - Double Density</LI>
      <LI><SPAN style="font-style: italic;">h</SPAN> - High Density</LI>
      <LI><SPAN style="font-style: italic;">e</SPAN> - Extra High Density</LI>
    </UL>
    
<P>Once this file is <SPAN style="font-style: italic;">OPEN</SPAN>ed, the file pointer is positioned at the start of the first sector of side 0 track 0 on the disk. Except on the ST/QL Drivers (pre D-04), no other file can be <SPAN style="font-style: italic;">OPEN</SPAN> on the disk if this access is to work. For further details on how data is stored on a directory device, please refer to the documentation of the device driver.</P>
    
<H3>Example:</H3>

<P>
    
<P>Read the name of a HD disk inserted in flp1_</P>
    <PRE>100 OPEN_IN #3,'flp1_*D2h'
110 GET #3\1+ 0*256 + 0*2^16,sector$
120 CLOSE #3
130 PRINT 'The First Sector of the disk is;'sector$
140 PRINT 'The name of the disk appears in this sector - it is ';sector$(5 to 14)
</PRE>
    
<H3>NOTE 1:</H3>

<P>
    
<P>Some older floppy disk interfaces do not support this.</P>
    
<H3>NOTE 2:</H3>

<P>
    
<P><SPAN style="font-style: italic;">MIDINET</SPAN> and <SPAN style="font-style: italic;">SERNET</SPAN> include code to stop you using this facility over the Network to access protected files.</P>
    
<H3>A12.6 LEVEL-1 DEVICE DRIVERS</H3>

<P>
    
<P>These were the first Directory Device Drivers provided with the QL (and early QL floppy / hard disk controllers) and allowed the QL to access files on microdrives, ram disk, floppy disk and hard disk relatively easily. Hard disks introduced their own system of storing a directory of the files (and also some introduced their own non-standard sub-directory filing system).</P>
    
<P><SPAN style="font-style: italic;">DIR</SPAN> would produce a list of all files present on the device (normally) in the order in which they were created. You could even have files with no names (for example flp1_ ).</P>
    
<P>The main problem with these drives was when you had a hard disk (or even a floppy disk) containing hundreds of files, it could be very difficult to find the required file.</P>
    
<P>The drivers could also not read files which had been placed in sub-directories on disks created by Level-2 Device Drivers.</P>
    
<H3>A12.7 LEVEL-2 DEVICE DRIVERS</H3>

<P>
    
<P>Level-2 device drivers were first introduced for the ST/QL emulator but are now available on several emulators and QL expansion boards. These allow the user to define sub-directories of sets of files on certain directory devices.</P>
    
<P>Sub-directories are identified by grouping together all files which have the same prefix. The main directory will only recognise the name of the sub-directory and you will then need to look at the sub-directory to obtain details of that set of files. For example, <SPAN style="font-style: italic;">DIR flp1_</SPAN> may produce the following output:-</P>
    <PRE>Example1
870/1440 sectors
boot
PSION-&gt;
</PRE>
    
<P>This would show that the disk in flp1_ had the medium name 'Example1' (see <SPAN style="font-style: italic;">FORMAT</SPAN>), had a maximum of 1440 sectors (720K) of which 870 remain unused, a boot file and a sub-directory called 'PSION' (see <SPAN style="font-style: italic;">MAKE_DIR</SPAN>). You could then use</P>
    
<P><SPAN style="font-style: italic;">DIR flp1_PSION</SPAN></P>
    
<P>to produce the following:</P>
    <PRE>Example1
870/1440 sectors
PSION_boot
PSION_Quill
</PRE>
    
<P>This still provides the same information about the disk, but goes on to show that the sub-directory 'PSION' contains the files 'PSION_boot' and 'PSION_Quill'.</P>
    
<P>The use of sub-directories help to make the finding of files much more easy, especially on devices like hard disk drives where there could be several thousand file names to sort through.</P>
    
<H3>A12.8 LEVEL-3 DEVICE DRIVERS</H3>

<P>
    
<P>These device drivers provide all of the facilities of earlier device drivers (allowing you to create sub-directories on Hard Disks, RAM Disks and Floppy Disks), plus giving you the ability to read from and write to PC and Atari TOS disks.</P>
    
<P>The <SPAN style="font-style: italic;">DIR</SPAN> command prints the type of the disk in the specified device.</P>
    
<P>Unfortunately, there are limited means of formatting PC and ATARI disks under the QL operating system and you have to use one of the various public domain utility programs to do so (or use the commands <SPAN style="font-style: italic;">AFORMAT</SPAN> and <SPAN style="font-style: italic;">IFORMAT</SPAN> if available).</P>
    
<P>If you try to write to an ATARI or PC format disk, then the filing system will look at the file name which you are using and if it is an invalid ATARI / PC filename (namely eight characters followed by a dot and a three letter extension) then a Not Found error may be reported. You are allowed to create sub-directories (up to four letters long) on an ATARI or PC disk with <SPAN style="font-style: italic;">MAKE_DIR</SPAN> and also save filenames without an extension (up to a maximum of 8 characters still).</P>
    
<P>Oddly, however, if you try to precede the three letter filename extension by an underscore (as would normally be the case on the QL), this is not translated to a dot, instead, this underscore is counted as one of the 8 characters in the filename.</P>
    
<P>A slight inconsistency (possibly in the way in which PCs handle sub-directories) is that if you make a sub-directory with the command:</P>
    
<P><SPAN style="font-style: italic;">MAKE_DIR flp1_TEST</SPAN></P>
    
<P><SPAN style="font-style: italic;">SAVE flp1_TEST.BAS</SPAN></P>
    
<P>will not actually place this file in the sub-directory - compare <SPAN style="font-style: italic;">SAVE flp1_TEST_TEST.BAS</SPAN>. You must also be aware that in keeping with PCs, you must create a sub-directory on DOS or TOS disks before you try to store a file in that sub-directory.</P>
    
<P>Until v2.52 of SMSQ/E, the filename needed to be in quote marks if it was to include a dot.</P>
    
<P>There is also a problem in that if you read some information from a DOS or TOS disk (for example with <SPAN style="font-style: italic;">LOAD</SPAN>) and then remove that disk from the drive and alter it on another computer, replacing the disk in the original computer's disk drive (not having used another disk in the mean time), it is impossible to tell that the disk has been modified, so any further attempt to access that disk may render it unuseable. If you must insist on doing this, use <SPAN style="font-style: italic;">DEL_DEFB</SPAN> before trying to access the disk a second time.</P>
    
<P>One more difficulty that has been rectified from version 2.87 of SMSQ/E, is that on earlier versions you could not use <SPAN style="font-style: italic;">EXEC</SPAN> or <SPAN style="font-style: italic;">EXEC_W</SPAN> (or similar command) to execute a file from a DOS or TOS disk - this is because the file type will not be 1. You needed to copy the file from the DOS or TOS disk to RAM disk and then use commands such as:</P>
    <PRE>OPEN #3,ram1_File_exe
HGET #3,length
HPUT #3,length,0,1,exdat
CLOSE #3
</PRE>
    
<P><SPAN style="font-style: italic;">exdat</SPAN> will depend upon the file itself (it is the extra information which can be stored in a QDOS file header) - you will need to read this from the original QDOS version of the file when it was created.</P>
    
<P>You will also find that some programs will not be able to use PC formatted disks - for example the Psion programs (such as Quill and QL-Xchange) which will both add a three letter extension preceded by an underscore if one does not exist (such as _doc).</P>
    
<H3>A12.9 USING ALIEN FORMAT DISKS</H3>

<P>
    
<P>QL Emulators which run on non-QL based hardware normally have a means of creating a section of the hard-disk connected to a computer which can be used for storage of QL files.</P>
    
<P>QPC also includes commands to allow you to access CD-ROM drives (see <SPAN style="font-style: italic;">CD_PLAY</SPAN>).</P>
    
<P>However, the problem comes when you need to try and read data from (or save data to) a floppy disk which is not in standard QDOS format.</P>
    
<P>There are several Public Domain and Commercial utilities which allow you to convert files from or to IBM or Atari Format disks into a QDOS format. Included amongst these utilities is the toolkit ATARIDOS (see <SPAN style="font-style: italic;">IQCONVERT</SPAN> for example). Other good examples are the public domain IBMDISK program, the commercial program XOVER (by Digital Precision) and the shareware program MultiDISCOVER (by Dave Walker).</P>
    
<P>However, if you want really flexible access to such disks, then you will need an operating system which includes Level-3 Device Drivers (see above).</P>
</BODY>
</HTML>
